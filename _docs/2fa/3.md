Letâ€™s add **rate limiting and retry attempt limits** to your **email-based 2FA** system so users canâ€™t brute-force or spam OTPs.
Weâ€™ll make it clean, reusable, and production-ready.

---

## ğŸ§© Goal

You already have a secure 2FA system:

- OTP (6-digit code)
- Hashed before saving
- 5-minute expiration

Now weâ€™ll prevent:

- ğŸš« Repeated wrong OTP attempts (brute-force)
- ğŸš« Rapid requests for new codes (spam)
- âœ… Optional: temporary lockout if too many failures

---

## âš™ï¸ Approaches to Secure 2FA Rate Limiting

| Protection Type                   | Description                                      | Implementation              |
| --------------------------------- | ------------------------------------------------ | --------------------------- |
| **Attempt counter**               | Limit OTP verification retries (e.g. max 3)      | Stored per user             |
| **Cooldown period**               | Prevent sending too many OTP emails (e.g. 1/min) | Store `lastOtpSentAt`       |
| **Temporary lockout**             | Disable account temporarily after repeated fails | Store `lockedUntil`         |
| **Express-rate-limit middleware** | Generic API rate limit                           | Middleware-level protection |

Weâ€™ll combine all three safely and elegantly.

---

## ğŸ§± Step 1: Update User Schema

Extend your user schema to track attempts & cooldowns:

```ts
const userSchema = new Schema<IUser>({
  name: String,
  email: String,
  password: String,
  isVerified: { type: Boolean, default: false },
  twoFactorEnabled: { type: Boolean, default: false },
  twoFactorCode: { type: String, default: null },
  twoFactorCodeExpires: { type: Date, default: null },
  twoFactorAttempts: { type: Number, default: 0 },
  lastTwoFactorSent: { type: Date, default: null },
  lockedUntil: { type: Date, default: null },
});
```

---

## ğŸ”’ Step 2: Prevent OTP Spamming (Send Cooldown)

In your `login` or â€œsend codeâ€ logic:

```ts
if (user.lastTwoFactorSent && Date.now() - user.lastTwoFactorSent.getTime() < 60 * 1000) {
  throw CustomError.TooManyRequests("Please wait 1 minute before requesting another code.");
}

const otp = generateOtp();
const hashedOtp = crypto.createHash("sha256").update(otp).digest("hex");

user.twoFactorCode = hashedOtp;
user.twoFactorCodeExpires = new Date(Date.now() + 5 * 60 * 1000);
user.lastTwoFactorSent = new Date();
await user.save({ validateBeforeSave: false });

await sendTwoFactorCode(user.email, otp);
```

âœ… This ensures users canâ€™t spam OTP emails â€” they must wait **60 seconds** before requesting another.

---

## ğŸ§© Step 3: Add OTP Retry Limit (max 3 attempts)

In your `verifyTwoFactorCode` controller:

```ts
if (user.lockedUntil && user.lockedUntil > new Date()) {
  throw CustomError.Forbidden("Account temporarily locked. Try again later.");
}

// Verify hashed OTP
const hashedCode = crypto.createHash("sha256").update(req.body.code).digest("hex");

const isValid = user.twoFactorCode === hashedCode && user.twoFactorCodeExpires! > new Date();

if (!isValid) {
  user.twoFactorAttempts += 1;

  // Lock after 3 failed attempts
  if (user.twoFactorAttempts >= 3) {
    user.lockedUntil = new Date(Date.now() + 10 * 60 * 1000); // 10 min lock
    user.twoFactorAttempts = 0;
  }

  await user.save({ validateBeforeSave: false });
  throw CustomError.BadRequest("Invalid or expired code");
}

// âœ… Success
user.twoFactorCode = null;
user.twoFactorCodeExpires = null;
user.twoFactorAttempts = 0;
user.lockedUntil = null;
await user.save({ validateBeforeSave: false });
```

âœ… Now:

- User gets **3 tries** before temporary lock (10 min)
- Attempts reset after successful verification

---

## ğŸ›¡ï¸ Step 4: Add Middleware Rate Limiting (per IP)

To prevent bots from hammering endpoints:

Install:

```bash
npm install express-rate-limit
```

Then in `src/middleware/rateLimiter.ts`:

```ts
import rateLimit from "express-rate-limit";

export const otpRequestLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 5, // max 5 OTP requests per IP per 5 min
  message: {
    success: false,
    message: "Too many OTP requests, please try again later.",
  },
});
```

Then in your routes:

```ts
import { otpRequestLimiter } from "../middlewares/rateLimiter";

router.post("/login", otpRequestLimiter, validateBody(validation.loginSchema), auth.login);
router.post(
  "/2fa/verify",
  otpRequestLimiter,
  validateBody(validation.verifyTwoFactorSchema),
  auth.verifyTwoFactorCode
);
```

âœ… This limits **any client** from spamming OTP-related endpoints, even across accounts.

---

## ğŸ§  Step 5: Summary of Security Layers

| Protection         | Implementation       | Purpose                   |
| ------------------ | -------------------- | ------------------------- |
| â±ï¸ Cooldown        | `lastTwoFactorSent`  | Prevent spam email sends  |
| ğŸ”¢ Attempt Counter | `twoFactorAttempts`  | Limit OTP retries         |
| ğŸ”’ Lockout         | `lockedUntil`        | Temporary user suspension |
| ğŸŒ IP Rate Limit   | `express-rate-limit` | Global anti-bot throttle  |
| ğŸ§¾ OTP Hashing     | `crypto.sha256`      | Protect stored OTP        |
| ğŸ•“ Expiration      | 5-minute TTL         | Ensure short validity     |

---

## ğŸ§© Example User Experience

### ğŸ” Login Flow

1ï¸âƒ£ User enters email/password
2ï¸âƒ£ Server sends code

- Wait 1 minute before requesting again
  3ï¸âƒ£ User enters 6-digit code
- 3 wrong attempts â†’ locked 10 minutes
  4ï¸âƒ£ On success â†’ issue tokens

---

## ğŸ’ Best Practice Recap

âœ… OTPs hashed in DB (cannot reverse)
âœ… OTPs expire in â‰¤5 min
âœ… Max 3 attempts per session
âœ… Max 1 email send per minute
âœ… Rate limit endpoints (per IP)
âœ… Lockout resets automatically
âœ… Clear all OTP data after success

---

## ğŸš€ Example: Putting It All Together (Summary Snippet)

```ts
// simplified verify flow
if (user.lockedUntil && user.lockedUntil > new Date()) throw CustomError.Forbidden("Locked");
const hashedCode = crypto.createHash("sha256").update(req.body.code).digest("hex");
const valid = user.twoFactorCode === hashedCode && user.twoFactorCodeExpires > new Date();

if (!valid) {
  user.twoFactorAttempts++;
  if (user.twoFactorAttempts >= 3) {
    user.lockedUntil = new Date(Date.now() + 10 * 60 * 1000);
    user.twoFactorAttempts = 0;
  }
  await user.save();
  throw CustomError.BadRequest("Invalid or expired code");
}

user.twoFactorCode = null;
user.twoFactorAttempts = 0;
user.lockedUntil = null;
await user.save();
```

---

âœ… This pattern is **used by banks, SaaS dashboards, and fintech apps** â€” lightweight, secure, and fast.
