Letâ€™s go step-by-step through **how to design and implement 2FA in a modern Express + TypeScript + MongoDB app** â€” the same stack youâ€™re already using.

---

# ğŸ§© What is 2FA?

Two-Factor Authentication means:

> A user must prove their identity using **two independent factors** before gaining access.

Usually:

1. **Something they know** â†’ password
2. **Something they have** â†’ phone, authenticator app, or email code

---

# âœ… Common 2FA Strategies

| Type              | Description                                                      | Example                             |
| ----------------- | ---------------------------------------------------------------- | ----------------------------------- |
| **TOTP-based**    | Time-based One-Time Password (Google Authenticator, Authy, etc.) | 6-digit rotating code               |
| **OTP via Email** | Temporary 6-digit code sent to email                             | Code expires in 5â€“10 minutes        |
| **OTP via SMS**   | Temporary code sent to phone                                     | Needs SMS provider like Twilio      |
| **Push-based**    | Mobile app push confirmation                                     | Complex setup (beyond backend only) |

For production systems, **TOTP (Google Authenticator)** is the best mix of **security + simplicity**.
Letâ€™s implement that ğŸ‘‡

---

# ğŸ—ï¸ Implementing 2FA (TOTP-based with Google Authenticator)

### Tech we'll use:

- **Express + TypeScript**
- **Speakeasy** â†’ generate and verify TOTP secrets
- **qrcode** â†’ generate scannable QR codes for setup
- **Mongoose** â†’ store secret for each user

---

## 1ï¸âƒ£ Install Dependencies

```bash
npm install speakeasy qrcode
```

---

## 2ï¸âƒ£ Update User Model

Add a field for the 2FA secret and a flag for enabling it.

```ts
const userSchema = new Schema<IUser>({
  name: String,
  email: String,
  password: String,
  isVerified: { type: Boolean, default: false },
  twoFactorEnabled: { type: Boolean, default: false },
  twoFactorSecret: { type: String, default: null },
});
```

---

## 3ï¸âƒ£ Enable 2FA Route (Setup)

When a verified user wants to enable 2FA, you generate a secret and show them a QR code to scan in Google Authenticator.

### **Route:** `POST /api/auth/2fa/setup`

```ts
import speakeasy from "speakeasy";
import QRCode from "qrcode";
import { Request, Response } from "express";
import { User } from "../models/user.model";

export const enable2FA = async (req: Request, res: Response) => {
  const userId = req.user.id; // assuming JWT middleware sets req.user

  const secret = speakeasy.generateSecret({
    name: `MyApp (${req.user.email})`,
  });

  // Save secret temporarily (not enabled yet)
  await User.findByIdAndUpdate(userId, { twoFactorSecret: secret.base32 });

  // Generate QR Code for Google Authenticator
  const qrCodeDataURL = await QRCode.toDataURL(secret.otpauth_url!);

  res.json({
    success: true,
    qrCode: qrCodeDataURL,
    manualCode: secret.base32,
  });
};
```

âœ… The user scans this QR code with Google Authenticator (or Authy),
which will start generating rotating 6-digit codes.

---

## 4ï¸âƒ£ Verify 2FA Setup

Once the user scans the QR, they must **verify** it works by entering the current 6-digit code.

### **Route:** `POST /api/auth/2fa/verify-setup`

```ts
export const verify2FASetup = async (req: Request, res: Response) => {
  const { token } = req.body;
  const user = await User.findById(req.user.id);

  if (!user?.twoFactorSecret) {
    return res.status(400).json({ message: "2FA not initialized" });
  }

  const verified = speakeasy.totp.verify({
    secret: user.twoFactorSecret,
    encoding: "base32",
    token,
    window: 1,
  });

  if (!verified) {
    return res.status(400).json({ message: "Invalid 2FA token" });
  }

  user.twoFactorEnabled = true;
  await user.save({ validateBeforeSave: false });

  res.json({ success: true, message: "2FA successfully enabled" });
};
```

---

## 5ï¸âƒ£ Enforce 2FA at Login

When a user logs in:

- Step 1 â†’ Validate email/password
- Step 2 â†’ If `twoFactorEnabled` is `true`, require the 6-digit code before issuing tokens.

### **Modified Login Flow**

```ts
export const login = async (req: Request, res: Response) => {
  const { email, password, token } = req.body;

  const user = await User.findOne({ email });
  if (!user) return res.status(400).json({ message: "Invalid credentials" });

  const isPasswordValid = await user.comparePassword(password);
  if (!isPasswordValid) return res.status(400).json({ message: "Invalid credentials" });

  // If 2FA enabled, verify token before issuing JWTs
  if (user.twoFactorEnabled) {
    if (!token) {
      return res.status(401).json({ message: "2FA code required" });
    }

    const isValid2FA = speakeasy.totp.verify({
      secret: user.twoFactorSecret!,
      encoding: "base32",
      token,
      window: 1,
    });

    if (!isValid2FA) {
      return res.status(401).json({ message: "Invalid 2FA code" });
    }
  }

  // Now issue tokens as before
  const payload = { id: user._id, email: user.email };
  const accessToken = await signAccessToken(payload);
  const refreshToken = await signRefreshToken(payload);

  user.refreshToken = refreshToken;
  await user.save({ validateBeforeSave: false });

  res.cookie("refreshToken", refreshToken, cookieOptions());
  res.json({ success: true, accessToken });
};
```

---

## 6ï¸âƒ£ Disable 2FA (Optional)

### **Route:** `POST /api/auth/2fa/disable`

```ts
export const disable2FA = async (req: Request, res: Response) => {
  await User.findByIdAndUpdate(req.user.id, {
    twoFactorEnabled: false,
    twoFactorSecret: null,
  });
  res.json({ success: true, message: "2FA disabled" });
};
```

---

## ğŸ§  Summary of the 2FA Flow

| Step  | Route               | Description                |
| ----- | ------------------- | -------------------------- |
| **1** | `/2fa/setup`        | Generate secret + QR Code  |
| **2** | `/2fa/verify-setup` | Verify token + enable 2FA  |
| **3** | `/login`            | Check 2FA token if enabled |
| **4** | `/2fa/disable`      | Disable 2FA for user       |

---

## ğŸ”’ Security Best Practices

âœ… **Never send `twoFactorSecret` to the client** after setup
âœ… **Always hash `twoFactorSecret`** if you need to store long-term (optional)
âœ… **Rotate secrets** if user resets password
âœ… **Use HTTPS** always
âœ… **Limit attempts** on 2FA code entry (e.g., max 3 tries per login)

---

## âš™ï¸ Bonus: Email-based 2FA Alternative (simpler)

If you donâ€™t want authenticator apps, you can send a **6-digit code to userâ€™s email** using Nodemailer or Resend.

- Store `twoFactorCode` + `twoFactorExpires` in DB
- On login â†’ generate code, email it
- Verify code before issuing JWT

This is less secure than TOTP but easier to use for most web apps.

---
